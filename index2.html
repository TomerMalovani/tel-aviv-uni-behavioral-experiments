<!DOCTYPE html>
<html>

<head>
	<title>My experiment</title>
	<script src="https://unpkg.com/jspsych@7.2.1"></script>
	<script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response@1.1.0"></script>
	<script type="text/javascript" src="trails.js"></script>
	<script type="text/javascript" src="testrun.js"></script>
	<link rel="stylesheet" href="https://unpkg.com/keyboard-css@1.2.2/dist/css/main.min.css" />

<script type="text/javascript" src="fc1_steps.json"></script>

<script src="https://unpkg.com/@jspsych/plugin-fullscreen@1.1.0"></script>
	<link href="https://unpkg.com/jspsych@7.2.1/css/jspsych.css" rel="stylesheet" type="text/css" />
</head>

<body>
	
</body>
<script>
		const goodResponeAudio = new Audio('feedback.wav');
			const badResponeAudio = new Audio('error.wav');

		let options = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', '', 'Tab'];
		const digitToNumber = {
				0: "10",
				q: "11",
				w: "12",
				e: "13",
				r: "14",
				t: "15",
				y: "16",
				u: "17",
				i: "18",
				o: "19",
				p: "20",
				Tab: "	",
				']':">20"
			}	
			const pause = {
					type: jsPsychHtmlKeyboardResponse,
					stimulus: '<p style="font-size: 25px;">press space to continue to next program</p>',
					// prompt: ">>>>>>",
					choices: " ",
				};  
	const loopFinishCheck=(itr,times,step)=>{
		return step >= (itr * times)
	}
	const isFeedBack=window.location.href.indexOf("feedback=1")>-1;
	const formatDiv=(currQuestion)=>{
		let base=`<div style="${(currQuestion.response_needed === "0") ? "font-size:20px; color:green;" : ""}">${currQuestion.text1}<br><p style="${(  currQuestion.text2 !== " ") ? 'margin-top:20px;border-top: 2px solid' : ""}">${currQuestion.text2}</p></div>`;
		base+=currQuestion.response_needed ==="0" ? ">>>>>>" : "";
		return  base

	}

	
	let timeLine=[]
	let fixAnswer = true;
		const formatDivLoopMode = (currQuestion, loop_step) => {
			let arr = currQuestion.text1.split("\r\n");

			let updatedText= arr[0] + "<br>" +  arr[loop_step];
			return updatedText;
			}

	steps.map((singalStep,index)=>{
			let loop_step=1;
			let loop_step_expected_response=null
			console.log("test",singalStep.expected_response?.split(","))
			if(singalStep.is_loop){
				if(loop_step===1){
					loop_step_expected_response = singalStep.expected_response?.split(",")[0]
					loop_step_expected_response.split('[')[1]
				}else if(loop_step=== singalStep.expected_response?.split(",").length){
					loop_step_expected_response = singalStep.expected_response?.split(",")[loop_step-1]
					loop_step_expected_response.split(']')[1]
				}
				else{

				loop_step_expected_response=singalStep.expected_response?.split(",")[loop_step-1]
				}
			}
			let trail = { 
				stimulus:formatDiv(singalStep),
					data: {
					correct_response: loop_step_expected_response ? loop_step_expected_response:singalStep.expected_response,
					correct: true,
				},
				on_finish:(data)=>{
					if(singalStep.is_loop){
						data.loop_step=loop_step;
					}
					data.correct_response=loop_step_expected_response ? loop_step_expected_response : singalStep.expected_response;
					if ((data.response === "backspace" && singalStep.is_loop && loopFinishCheck(singalStep.n_iterations, singalStep.n_loop_lines, loop_step))) {
						fixAnswer = false;
						
					}else{
						fixAnswer = true;
					}
				}
			 }
			let question = {
			type: jsPsychHtmlKeyboardResponse,
			timeline:[trail],
			// prompt: singalStep.trial_code,
		
			loop_function: function (data) {
				if (!singalStep.is_loop) {
					return false;
				}
				if(loopFinishCheck(singalStep.n_iterations,singalStep.n_loop_lines,loop_step) && data.trials[0].response === "backspace"){
					return false;
				}else if(data.trials[0].response !== "backspace"){
					loop_step++;
					data.loop_step= loop_step;
					return true
				}
				return false
				

				
			},
			on_finish: function (data) {
				if (singalStep.expected_response !== " ") {
					if(singalStep.is_loop && data.response!=="backspace" && loop_step === (singalStep.n_iterations * singalStep.n_loop_lines)){
						data.correct = false;
						isFeedBack && badResponeAudio.play();
					}
					else if (jsPsych.pluginAPI.compareKeys(data.response, singalStep.expected_response) || jsPsych.pluginAPI.compareKeys(digitToNumber[data.response], singalStep.expected_response)) {
					
						fixAnswer = false;
						isFeedBack && goodResponeAudio.play();
						data.response = digitToNumber[data.response]
					} else {
					
						data.correct = false;
						isFeedBack && badResponeAudio.play();
					}
				}

			},

			choices: singalStep.is_loop ? ["backspace",...options] : (singalStep.response_needed ? options : "ALL_KEYS"),
		}
				let if_node = {
			type: jsPsychHtmlKeyboardResponse,
			timeline: [{ stimulus: `right answer:${singalStep.expected_response}` }],

			choices: "ALL_KEYS",

			conditional_function: function () {
				return fixAnswer && !singalStep.is_loop &&singalStep.expected_response !== null && (window.location.href.indexOf("feedback=1") > -1)
			}
		}
			let if_node_loop = {
			type: jsPsychHtmlKeyboardResponse,
			timeline: [{ stimulus:"end of loop" }],

			choices: "ALL_KEYS",

			conditional_function: function () {
				return fixAnswer && loop_step >= (singalStep.n_iterations * singalStep.n_loop_lines) && singalStep.is_loop && singalStep.expected_response !== null && (window.location.href.indexOf("feedback=1") > -1)
			}
		}
		question.timeline.push(if_node)
		question.timeline.push(if_node_loop)
		timeLine = [...timeLine, question]
	})

	const enter_fullscreen = {
			type: jsPsychFullscreen,
			fullscreen_mode: true,
			
		}
	const exit_fullscreen = {
			type: jsPsychFullscreen,
			fullscreen_mode: false,
			delay_after: 0
		}

	 let amoutOfTests = Math.floor(Math.random() * (80 - 20 + 1) + 20)
	const jsPsych = initJsPsych({
		
		show_progress_bar: true,
		
		on_finish: function () {
			jsPsych.data.get().localSave('csv', 'mydata.csv');
		}
	});



		 jsPsych.run([enter_fullscreen,...timeLine, exit_fullscreen]);
	


	

	
</script>

</html>